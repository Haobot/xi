/*********************************************************************************************
 *
 *                                     * * * Xi4s * * *
 *
 *********************************************************************************************
 * Created by afy on 8/24/14.
 *
 * This is the Xi Client for Scratch
 *
 * It follows the Scratch JavaScript Extension Spec
 *
 * http://llk.github.io/scratch-extension-docs/
 *
 * Version v.001
 *
 *
 * @author: Alan Yorinks
 Copyright (c) 2014 Alan Yorinks All right reserved.

 This program is free software; you can redistribute it and/or
 modify it under the terms of the GNU General Public
 License as published by the Free Software Foundation; either
 version 3.0 of the License, or (at your option) any later version.

 This library is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 Lesser General Public License for more details.

 You should have received a copy of the GNU General Public
 License along with this library; if not, write to the Free Software
 Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
 *
 */

new (function () {
    var ext = this;
    console.log('Xi4s v.001');

    // 0 = no debug
    // 1 = low level debug
    // 2 = high - open the floodgates
    // Variable is set by user through a Scratch command block
    var debugLevel = 0;

    // a variable to set the color of the 'LED' indicator for the extension on the Scratch editor
    var boardStatus = 0; //  0:not ready(RED), 1:partially ready or warning(YELLOW), 2: fully ready(GREEN)

    // Board IP addresses and ports are set by the user with a Scratch command block, and the information
    // is stored in the WebSocket Array

    // WebSocket array
    //   Each board will have an associated WebSocket instance used for communication
    //   with the Xi client. webSocketsArray is an array of objects. Each object has a format of:
    //   {id: BoardID, , ip: IPAddress, port: port, ws: WebSocketReference}

    var webSocketsArray = [];

    // Sensor Data Array
    // This is an array of objects that store the latest sensor or switch value updates received from all Xi servers.
    // The object format is:
    //      key:      generated by genReporterKey()
    //      value:    latest updated value
    // A key is used to uniquely identify each data entry with a specific sensor on a specific server
    var sensorDataArray = [];

    /********************* asynchronous messages from scratch ****************************************/
        // Cleanup function when the extension is unloaded
    ext._shutdown = function () {
        //send a 'resetBoard'  message to each board
        for (var index = 0; index < webSocketsArray.length; index++) {
            if (debugLevel >= 2) {
                console.log('Sending reset to board index ' + index);
            }
            webSocketsArray[index].ws.send('resetBoard');
        }
    };

    // Status reporting code - part of boilerplate provided by Scratch
    // Set the 'LED' on the Scratch Editor
    ext._getStatus = function () {
        return {
            status: boardStatus,
            msg: 'Ready'
        };
    };

    /*****************************************************************************************************/
    /***********************************   Scratch Program Block Handlers, ******************************/
    /*****************************************************************************************************/

    // Associate a handler for each block described in the blocks section below

    /*******************************
     **** Command Block Handlers ****
     *******************************/

        // Accepts IP Address and Port information for each board that the user adds
        // The associated scratch block is a 'wait' command block.
        // We don't want Scratch to continue until the socket is open bidirectionally.
        // When socket.onopen is called the callback is returned so that scratch can proceed processing
    ext.setBoard = function (boardID, ipAddress, port, callback) {
        var timeoutID; // need to set a timeout when a socket is created because we are using a 'wait' block


        if (debugLevel >= 1)
            console.log('setBoard: ' + boardID, ipAddress, port);

        // Check to make sure that this board was not entered previously
        for (var index = 0; index < webSocketsArray.length; index++) {
            if (webSocketsArray[index].id === boardID) {
                // allow user to reset the board to the same value - for stop and start
                if ((webSocketsArray[index].ip != ipAddress) || (webSocketsArray[index].port != port)) {
                    alert('An IP entry already exists for board ' + boardID + '!');
                    callback(); // release the scratch wait block
                    return; // no need to go further
                }
            }
        }
        // This is a confirmed unique entry. Create a websocket for this board
        var socket = new WebSocket('ws://' + ipAddress + ':' + port);

        // add the entry including the websocket reference just created
        webSocketsArray.push({'id': boardID, 'ip': ipAddress, 'port': port, 'ws': socket});

        // start the timer for a server reply - we wait for up to 2 seconds for the reply
        timeoutID = window.setTimeout(noServerAlert, 2000);


        // attach an onopen handler to this socket. This message is sent by a servers websocket
        socket.onopen = function (event) {
            window.clearTimeout(timeoutID);
            if (debugLevel >= 1)
                console.log('onopen message received');
            // change the board status to green with the first board added, since we don't know ahead of time
            // how many boards are attached
            boardStatus = 2;
            socket.send('Xi4sOnline');
            callback(); // tell scratch to proceed processing
        };

        function noServerAlert() {
            alert('Server not responding. Did you start XiServer for board ' +
                boardID + '? Start the server, reload this page and try again');
            // we set the board status back to 0
            boardStatus = 0;
        }

        /**********************  websocket 'onmessage' handler *************************************/
            //
            // All messages sent from board's socket are handled here.
            // Attach an onmessage event handler to this socket.
            // Process messages received from the server associated with this socket.
        socket.onmessage = function (message) {
            if (debugLevel === 1)
                console.log('onmessage received: ' + message.data);

            // All message components are delimited with '/' character.
            // TODO: Should this be done with JSON?

            // Incoming messages are split into their component pieces and placed into a 'msg' array
            // msg[0] for each message is the message ID.
            var msg = message.data.split('/');

            // process each message ID
            switch (msg[0]) {
                // dataUpdate - server data update data message
                case 'dataUpdate':
                    var index = msg[1]; // unique value used as an index into sensorDataArray
                    var data = msg[2]; // data value to be entered into sensorDataArray
                    if (debugLevel >= 2)
                        console.log('sensorData: index = ' + index + ' data = ' + data);
                    // update the array with the new value
                    sensorDataArray[index].value = data;
                    break;

            /***************************************
             ************** server detected errors
             ****************************************/

                // server detected a problem in setting the mode of this pin
                case 'invalidSetMode':
                    alert(msg[1]);
                    break;
                case 'invalidPinCommand':
                    alert(msg[1]);
                    break;
                default:
                    if (debugLevel >= 1)
                        console.log('onmessage unknown message received');
            }
        };
    };

    // Set the pin mode command block handler
    ext.pinMode = function (boardID, pin, mode) {
        if (debugLevel >= 1)
            console.log('Set Pin Mode - board: ' + boardID + ' Mode: ' + mode + ' Pin: ' + pin);
        // make sure the websocket for the board was previously established
        for (var index = 0; index < webSocketsArray.length; index++) {
            if (webSocketsArray[index].id === boardID) {
                // send message to server to create device(input devices) or set the pin mode (output device)
                var messageToServer; // message to be sent to server

                // the mode is the value prescribed in block descriptor section
                switch (mode) {
                    // set pin to digital input mode
                    // msg: setDigitalIN - digital service input
                    case 'Digital Input':
                        if (debugLevel >= 1)
                            console.log('pin mode digital input');
                        // build the message to send to the Xi Server
                        // we use the length of the array as the index/device id
                        messageToServer = 'setDigitalIN/' + boardID + '/' + pin + '/' + sensorDataArray.length;
                        sendSetInputPinRequest(messageToServer, 'd', boardID, pin, index);
                        break;
                    // set pin to digital out
                    // msg: setDigitalOUT
                    case 'Digital Output':
                        if (debugLevel >= 1)
                            console.log('pin mode digital output');
                        messageToServer = 'setDigitalOUT/' + boardID + '/' + pin;
                        if (debugLevel >= 2)
                            console.log('pinMode Digital Out Msg to server: ' + messageToServer);
                        webSocketsArray[index].ws.send(messageToServer);
                        break;
                    // set pin to analog in
                    // msg: setAnalogIN
                    case 'Analog Sensor Input':
                        if (debugLevel >= 1)
                            console.log('pin mode analog input');
                        // build the message to send to the Xi Server
                        // we use the length of the array as the index/device id
                        messageToServer = 'setAnalogIN/' + sensorDataArray.length + '/' + boardID + '/' + pin;
                        sendSetInputPinRequest(messageToServer, 'a', boardID, pin, index);
                        break;
                    // set pin mode PWM
                    // msg: setAnalogOUT
                    case 'Analog (PWM) Output':
                        if (debugLevel >= 1)
                            console.log('pin mode PWM');
                        // send out the pwm mode message
                        // the host tests if the pin is PWM and if not will send back an 'xp' message
                        messageToServer = 'setAnalogOUT/' + boardID + '/' + pin;
                        if (debugLevel >= 2)
                            console.log('pinMode PWM Out Msg to server: ' + messageToServer);
                        webSocketsArray[index].ws.send(messageToServer);
                        break;
                    default:
                        if (debugLevel >= 1)
                            console.log('ext.pinMode: Unknown mode - ', +mode);
                }
                // just return from here after processing the command
                return;
            }
        }
        // board not yet established
        alert('Board ' + boardID + ' IP address must be set before a board is used');
    };

    // Digital output command block
    ext.digitalWrite = function (board, pin, value) {
        if (debugLevel >= 1) {
            console.log('digitalWrite Board: ' + board + ' Pin ' + pin + ' Value ' + value);
        }
        var msg = 'digitalWrite/' + board + '/' + pin + '/' + value;
        sendCommand(msg, board, 'digitalWrite');
    };

    // PWM output (analog write)  command block
    ext.analogWrite = function (board, pin, value) {
        var msg = 'analogWrite/' + board + '/' + pin + '/' + value;
        sendCommand(msg, board, 'analogWrite');
    };

    // Set the debug level
    ext.setDebugLevel = function (level) {
        debugLevel = level;
    };


    /*******************************
     **** Command Block Handlers ****
     *******************************/

        // retrieve digital data from sensorDataArray
    ext.getDigitalInputData = function (board, pin) {
        if (debugLevel >= 1)
            console.log('Digital Input - board: ' + board + ' Pin: ' + pin);
        var key = genReporterKey(board, pin, 'd');
        return retrieveReporterData(board, pin, key);
    };

    // retrieve analog data data from sensorDataArray
    ext.getAnalogSensorData = function (board, pin) {
        if (debugLevel >= 1)
            console.log('Analog Sensor Input - board: ' + board + ' Pin: ' + pin);

        // generate a key for sensorDataArray
        var key = genReporterKey(board, pin, 'a');
        return retrieveReporterData(board, pin, key);
    };


    // helper functions

    //genReporterKey
    // Input: Board number
    //        Pin number
    //        Designator to differentiate between analog and digital - either 'a' or 'd'
    //
    // Returns the generated key
    function genReporterKey(boardNum, pinNum, designator) {
        if (debugLevel >= 1)
            console.log('genReporterKey returns: ' + boardNum + designator + pinNum);
        return boardNum + designator + pinNum;
    }

    // Using the supplied key, this function will retrieve the latest data from the sensorDataArray.
    function retrieveReporterData(board, pin, key) {
        // make sure that this is a unique key in the array
        for (var index = 0; index < sensorDataArray.length; index++) {
            if (sensorDataArray[index].key === key) {
                return sensorDataArray[index].value
            }
        }
        // did not find an entry in the array
        alert('Did you set the pin mode for Board ' + board + ' Pin ' + pin +
            '? No entry for this block in database');
        ext._shutdown();
    }

    // This function will format a set input pin message (analog or digital) and send it to the server
    function sendSetInputPinRequest(msgToServer, analogOrDigital, board, pin, wsIndex) {
        var reporterArrayEntry = {key: null, data: -1}; // The entry we build to add to the sensorDataArray

        // generate a key so that we can use to retrieve the data from the reporterArrayEntry
        reporterArrayEntry.key = genReporterKey(board, pin, analogOrDigital);

        if (debugLevel >= 1)
            console.log('sendInputPinRequest generated key = ' + reporterArrayEntry.key);

        var found = false;
        // make sure that this is a unique key in the array
        for (var index = 0; index < sensorDataArray.length; index++) {
            if (sensorDataArray[index].key === reporterArrayEntry.key) {
                found = true;
                console.log("sendInputPinReq entry exists");
            }
        }


        // it is unique so go ahead and add the record to the array
        if (found === false) {
            sensorDataArray.push(reporterArrayEntry);
            //}
            // now we can safely send the set pin message to the Xi Server to create the device
            if (debugLevel >= 1)
                console.log('sendInputPinRequest: msg = ' + msgToServer + ' index = ' + wsIndex);
            webSocketsArray[wsIndex].ws.send(msgToServer);
        }
    }

    // This function will check to see if a board has been established and if it has, will send a command
    // message to the server
    function sendCommand(msg, board, type) {
        if (debugLevel >= 1) {
            console.log('sendCommand: ' + msg + ' ' + board + ' ' + type);
        }
        for (var index = 0; index < webSocketsArray.length; index++) {
            if (webSocketsArray[index].id === board) {
                if (debugLevel >= 2)
                    console.log('sendCommand: Message: ' + msg + ' board: ' + board);
                // send out message
                webSocketsArray[index].ws.send(msg);
                return;
            }
        }
        // board was not established
        alert(type + ' IP address for board ' + board + ' was not set');
    }

    // Block and block menu descriptions
    var descriptor = {
        blocks: [
            ['w', 'Board %m.bdNum IPAddress/Port: %s : %s', 'setBoard', '1', 'localhost', '1234' ],
            [' ', 'Board: %m.bdNum Set Pin %n as %m.pinMode', 'pinMode', '1', '2', 'Digital Input' ],
            [' ', 'Board: %m.bdNum Digital Write Pin %n = %m.onOff ', 'digitalWrite', '1', '2', 'Off'],
            [' ', 'Board: %m.bdNum Analog Write(PWM) Pin %n = %n', 'analogWrite', '1', '3', '128'],
            [' ', 'Set Debug Level %m.dbgLevel', 'setDebugLevel', '0'],
            ['r', 'Board: %m.bdNum Digital Input on Pin %n', 'getDigitalInputData', '1', '2'],
            ['r', 'Board: %m.bdNum Analog Sensor Input on Pin %n', 'getAnalogSensorData', '1', '2']
        ],
        menus: {
            bdNum: [ '1', '2', '3', '4', '5', '6', '7', '8', '9', '10'],
            dbgLevel: ['0', '1', '2'],
            onOff: ['Off', 'On'],
            pinMode: ['Digital Input', 'Digital Output', 'Analog Sensor Input', 'Analog (PWM) Output']
        },

        url: 'http://mryslab.blogspot.com/'
    };


    // Register the extension
    ScratchExtensions.register('Xi4S_v_001', descriptor, ext);

})();
